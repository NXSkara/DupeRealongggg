do local StrToNumber=tonumber;local Byte=string.byte;local Char=string.char;local Sub=string.sub;local Subg=string.gsub;local Rep=string.rep;local Concat=table.concat;local Insert=table.insert;local LDExp=math.ldexp;local GetFEnv=getfenv or function()return _ENV;end ;local Setmetatable=setmetatable;local PCall=pcall;local Select=select;local Unpack=unpack or table.unpack ;local ToNumber=tonumber;local function VMCall(ByteString,vmenv,...)local DIP=1;local repeatNext;ByteString=Subg(Sub(ByteString,5),"..",function(byte)if (Byte(byte,2)==79) then repeatNext=StrToNumber(Sub(byte,1,1));return "";else local a=Char(StrToNumber(byte,16));if repeatNext then local b=Rep(a,repeatNext);repeatNext=nil;return b;else return a;end end end);local function gBit(Bit,Start,End)if End then local Res=(Bit/(2^(Start-1)))%(2^(((End-1) -(Start-1)) + 1)) ;return Res-(Res%1) ;else local Plc=2^(Start-1) ;return (((Bit%(Plc + Plc))>=Plc) and 1) or 0 ;end end local function gBits8()local a=Byte(ByteString,DIP,DIP);DIP=DIP + 1 ;return a;end local function gBits16()local a,b=Byte(ByteString,DIP,DIP + 2 );DIP=DIP + 2 ;return (b * 256) + a ;end local function gBits32()local a,b,c,d=Byte(ByteString,DIP,DIP + 3 );DIP=DIP + 4 ;return (d * 16777216) + (c * 65536) + (b * 256) + a ;end local function gFloat()local Left=gBits32();local Right=gBits32();local IsNormal=1;local Mantissa=(gBit(Right,1,20) * (2^32)) + Left ;local Exponent=gBit(Right,21,31);local Sign=((gBit(Right,32)==1) and  -1) or 1 ;if (Exponent==0) then if (Mantissa==0) then return Sign * 0 ;else Exponent=1;IsNormal=0;end elseif (Exponent==2047) then return ((Mantissa==0) and (Sign * (1/0))) or (Sign * NaN) ;end return LDExp(Sign,Exponent-1023 ) * (IsNormal + (Mantissa/(2^52))) ;end local function gString(Len)local Str;if  not Len then Len=gBits32();if (Len==0) then return "";end end Str=Sub(ByteString,DIP,(DIP + Len) -1 );DIP=DIP + Len ;local FStr={};for Idx=1, #Str do FStr[Idx]=Char(Byte(Sub(Str,Idx,Idx)));end return Concat(FStr);end local gInt=gBits32;local function _R(...)return {...},Select("#",...);end local function Deserialize()local Instrs={};local Functions={};local Lines={};local Chunk={Instrs,Functions,nil,Lines};local ConstCount=gBits32();local Consts={};for Idx=1,ConstCount do local Type=gBits8();local Cons;if (Type==1) then Cons=gBits8()~=0 ;elseif (Type==2) then Cons=gFloat();elseif (Type==3) then Cons=gString();end Consts[Idx]=Cons;end Chunk[3]=gBits8();for Idx=1,gBits32() do local Descriptor=gBits8();if (gBit(Descriptor,1,1)==0) then local Type=gBit(Descriptor,2,3);local Mask=gBit(Descriptor,4,6);local Inst={gBits16(),gBits16(),nil,nil};if (Type==0) then Inst[3]=gBits16();Inst[4]=gBits16();elseif (Type==1) then Inst[3]=gBits32();elseif (Type==2) then Inst[3]=gBits32() -(2^16) ;elseif (Type==3) then Inst[3]=gBits32() -(2^16) ;Inst[4]=gBits16();end if (gBit(Mask,1,1)==1) then Inst[2]=Consts[Inst[2]];end if (gBit(Mask,2,2)==1) then Inst[3]=Consts[Inst[3]];end if (gBit(Mask,3,3)==1) then Inst[4]=Consts[Inst[4]];end Instrs[Idx]=Inst;end end for Idx=1,gBits32() do Functions[Idx-1 ]=Deserialize();end return Chunk;end local function Wrap(Chunk,Upvalues,Env)local Instr=Chunk[1];local Proto=Chunk[2];local Params=Chunk[3];return function(...)local Instr=Instr;local Proto=Proto;local Params=Params;local _R=_R;local VIP=1;local Top= -1;local Vararg={};local Args={...};local PCount=Select("#",...) -1 ;local Lupvals={};local Stk={};for Idx=0,PCount do if (Idx>=Params) then Vararg[Idx-Params ]=Args[Idx + 1 ];else Stk[Idx]=Args[Idx + 1 ];end end local Varargsz=(PCount-Params) + 1 ;local Inst;local Enum;while true do Inst=Instr[VIP];Enum=Inst[1];if (Enum<=17) then if (Enum<=8) then if (Enum<=3) then if (Enum<=1) then if (Enum>0) then Stk[Inst[2]]={};else local A=Inst[2];local Step=Stk[A + 2 ];local Index=Stk[A] + Step ;Stk[A]=Index;if (Step>0) then if (Index<=Stk[A + 1 ]) then VIP=Inst[3];Stk[A + 3 ]=Index;end elseif (Index>=Stk[A + 1 ]) then VIP=Inst[3];Stk[A + 3 ]=Index;end end elseif (Enum>2) then Stk[Inst[2]]=Stk[Inst[3]] * Stk[Inst[4]] ;else local A=Inst[2];Stk[A](Stk[A + 1 ]);end elseif (Enum<=5) then if (Enum==4) then VIP=Inst[3];else do return;end end elseif (Enum<=6) then Stk[Inst[2]][Stk[Inst[3]]]=Stk[Inst[4]];elseif (Enum>7) then if (Stk[Inst[2]]==Inst[4]) then VIP=VIP + 1 ;else VIP=Inst[3];end elseif Stk[Inst[2]] then VIP=VIP + 1 ;else VIP=Inst[3];end elseif (Enum<=12) then if (Enum<=10) then if (Enum==9) then local Step;local Index;local A;Stk[Inst[2]]=Stk[Inst[3]];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Inst[3];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Stk[Inst[3]];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Inst[3];VIP=VIP + 1 ;Inst=Instr[VIP];A=Inst[2];Index=Stk[A];Step=Stk[A + 2 ];if (Step>0) then if (Index>Stk[A + 1 ]) then VIP=Inst[3];else Stk[A + 3 ]=Index;end elseif (Index<Stk[A + 1 ]) then VIP=Inst[3];else Stk[A + 3 ]=Index;end else local A=Inst[2];do return Unpack(Stk,A,A + Inst[3] );end end elseif (Enum>11) then Stk[Inst[2]][Stk[Inst[3]]]=Inst[4];else Stk[Inst[2]]=Inst[3]~=0 ;end elseif (Enum<=14) then if (Enum>13) then Stk[Inst[2]]=Stk[Inst[3]][Stk[Inst[4]]];else local A=Inst[2];local Results,Limit=_R(Stk[A](Stk[A + 1 ]));Top=(Limit + A) -1 ;local Edx=0;for Idx=A,Top do Edx=Edx + 1 ;Stk[Idx]=Results[Edx];end end elseif (Enum<=15) then local A;Env[Inst[3]]=Stk[Inst[2]];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Env[Inst[3]];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Inst[3];VIP=VIP + 1 ;Inst=Instr[VIP];A=Inst[2];Stk[A]=Stk[A](Stk[A + 1 ]);VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Stk[Inst[3]];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Inst[3];elseif (Enum==16) then Stk[Inst[2]]=Stk[Inst[3]];else local A=Inst[2];Stk[A]=Stk[A](Stk[A + 1 ]);end elseif (Enum<=26) then if (Enum<=21) then if (Enum<=19) then if (Enum>18) then Stk[Inst[2]]=Inst[3]~=0 ;VIP=VIP + 1 ;elseif (Stk[Inst[2]]<Stk[Inst[4]]) then VIP=VIP + 1 ;else VIP=Inst[3];end elseif (Enum==20) then Stk[Inst[2]]=Inst[3];else local A=Inst[2];Stk[A]=Stk[A](Unpack(Stk,A + 1 ,Top));end elseif (Enum<=23) then if (Enum==22) then Env[Inst[3]]=Stk[Inst[2]];else local B=Inst[3];local K=Stk[B];for Idx=B + 1 ,Inst[4] do K=K   .. Stk[Idx] ;end Stk[Inst[2]]=K;end elseif (Enum<=24) then local A=Inst[2];local C=Inst[4];local CB=A + 2 ;local Result={Stk[A](Stk[A + 1 ],Stk[CB])};for Idx=1,C do Stk[CB + Idx ]=Result[Idx];end local R=Result[1];if R then Stk[CB]=R;VIP=Inst[3];else VIP=VIP + 1 ;end elseif (Enum>25) then Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];else local Step;local Index;local Edx;local Results,Limit;local A;Stk[Inst[2]]=Env[Inst[3]];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Env[Inst[3]];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Stk[Inst[3]][Inst[4]];VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Stk[Inst[3]];VIP=VIP + 1 ;Inst=Instr[VIP];A=Inst[2];Results,Limit=_R(Stk[A](Stk[A + 1 ]));Top=(Limit + A) -1 ;Edx=0;for Idx=A,Top do Edx=Edx + 1 ;Stk[Idx]=Results[Edx];end VIP=VIP + 1 ;Inst=Instr[VIP];A=Inst[2];Stk[A]=Stk[A](Unpack(Stk,A + 1 ,Top));VIP=VIP + 1 ;Inst=Instr[VIP];Stk[Inst[2]]=Inst[3];VIP=VIP + 1 ;Inst=Instr[VIP];A=Inst[2];Index=Stk[A];Step=Stk[A + 2 ];if (Step>0) then if (Index>Stk[A + 1 ]) then VIP=Inst[3];else Stk[A + 3 ]=Index;end elseif (Index<Stk[A + 1 ]) then VIP=Inst[3];else Stk[A + 3 ]=Index;end end elseif (Enum<=30) then if (Enum<=28) then if (Enum==27) then Stk[Inst[2]]=Stk[Inst[3]] + Inst[4] ;else for Idx=Inst[2],Inst[3] do Stk[Idx]=nil;end end elseif (Enum==29) then Stk[Inst[2]]=Inst[3] + Stk[Inst[4]] ;else Stk[Inst[2]]=Wrap(Proto[Inst[3]],nil,Env);end elseif (Enum<=32) then if (Enum>31) then if (Inst[2]==Stk[Inst[4]]) then VIP=VIP + 1 ;else VIP=Inst[3];end else local A=Inst[2];local Results={Stk[A](Stk[A + 1 ])};local Edx=0;for Idx=A,Inst[4] do Edx=Edx + 1 ;Stk[Idx]=Results[Edx];end end elseif (Enum<=33) then local A=Inst[2];local Index=Stk[A];local Step=Stk[A + 2 ];if (Step>0) then if (Index>Stk[A + 1 ]) then VIP=Inst[3];else Stk[A + 3 ]=Index;end elseif (Index<Stk[A + 1 ]) then VIP=Inst[3];else Stk[A + 3 ]=Index;end elseif (Enum==34) then Stk[Inst[2]]=Env[Inst[3]];else do return Stk[Inst[2]];end end VIP=VIP + 1 ;end end;end return Wrap(Deserialize(),{},vmenv)(...);end VMCall("LOL!143O00028O00026O000840026O00F03F03053O007072696E7403193O006F62667573636174652074686520636F6E646974696F6E732103343O00436C69636B696E67205B537472696E67735D2077692O6C20636F6D706C6574656C792068696465207468697320737472696E6721026O00104003153O0073696576655F6F665F657261746F737468656E6573025O00407A4003053O007061697273030D3O005072696D6520666F756E643A2003163O00486F7720746F206F626675736361746520626573743F024O00F0E4FD40026O003440025O00C05940027O0040023O00406E9B5E4103043O0074727565025O005D3241024O0087C6324100773O0012143O00014O001C000100043O0026083O001600010002002O043O00160001001214000500013O0026080005001100010001002O043O0011000100101D0006000300040006120003000D00010006002O043O000D0001001222000600043O001214000700054O0002000600020001001222000600043O001214000700064O0002000600020001001214000500033O000E200003000500010005002O043O000500010012143O00073O002O043O00160001002O043O000500010026083O004900010007002O043O00490001001214000500014O001C000600073O0026080005003F00010003002O043O003F0001000E200001002D00010006002O043O002D0001001214000800013O0026080008002800010001002O043O0028000100021E00095O00120F000900083O00122O000900083O00122O000A00096O0009000200024O000700093O00122O000800033O0026080008001F00010003002O043O001F0001001214000600033O002O043O002D0001002O043O001F00010026080006001C00010003002O043O001C00010012220008000A4O0010000900074O001F00080002000A002O043O003A0001000607000C003A00013O002O043O003A0001001222000D00043O001214000E000B4O0010000F000B4O0017000E000E000F2O0002000D000200010006180008003300010002002O043O00330001002O043O00450001002O043O001C0001002O043O004500010026080005001A00010001002O043O001A0001001214000600014O001C000700073O001214000500033O002O043O001A0001001222000500043O0012140006000C4O0002000500020001002O043O007600010026083O005700010001002O043O00570001001214000500013O0026080005005000010003002O043O005000010012143O00033O002O043O005700010026080005004C00010001002O043O004C00010012140001000D3O00201B00060001000E00201B00010006000F001214000500033O002O043O004C00010026083O006800010010002O043O00680001001214000500013O0026080005005E00010003002O043O005E00010012143O00023O002O043O006800010026080005005A00010001002O043O005A0001001214000400113O0006120002006600010003002O043O00660001001222000600043O001214000700124O0002000600020001001214000500033O002O043O005A00010026083O000200010003002O043O00020001001214000500013O0026080005006F00010003002O043O006F00010012143O00103O002O043O000200010026080005006B00010001002O043O006B0001001214000200133O001214000300143O001214000500033O002O043O006B0001002O043O000200012O00053O00013O00013O00073O00028O00026O00F03F027O004003043O006D61746803053O00666C2O6F7203043O00737172740100013C3O001214000100014O001C000200033O0026080001003500010002002O043O00350001001214000400013O0026080004000500010001002O043O000500010026080002002200010002002O043O00220001001214000500013O0026080005000A00010001002O043O000A0001001214000600033O001219000700043O00202O00070007000500122O000800043O00202O0008000800064O00098O000800096O00073O000200122O000800023O00042O0006002000012O000E000A00030009000607000A001F00013O002O043O001F00012O0003000A000900092O0010000B6O0010000C00093O000421000A001F000100200C0003000D000700042O000A001D000100042O0006001600012O0023000300023O002O043O000A00010026080002000400010001002O043O000400012O000100056O0009000300053O00122O000500026O00065O00122O000700023O00042O000500300001000E200002002D00010008002O043O002D00012O001300096O000B000900014O000600030008000900042O0005002A0001001214000200023O002O043O00040001002O043O00050001002O043O00040001002O043O003B0001000E200001000200010001002O043O00020001001214000200014O001C000300033O001214000100023O002O043O000200012O00053O00017O00",GetFEnv(),...); end
